<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sui-notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="history.html"><strong aria-hidden="true">3.</strong> History</a></li><li class="chapter-item expanded "><a href="before-we-begin/index.html"><strong aria-hidden="true">4.</strong> Before we begin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="before-we-begin/install-sui.html"><strong aria-hidden="true">4.1.</strong> Install Sui</a></li><li class="chapter-item expanded "><a href="before-we-begin/ide-support.html"><strong aria-hidden="true">4.2.</strong> Set up your IDE</a></li><li class="chapter-item expanded "><a href="before-we-begin/move-2024.html"><strong aria-hidden="true">4.3.</strong> Move 2024</a></li></ol></li><li class="chapter-item expanded "><a href="your-first-move/your-first-move.html"><strong aria-hidden="true">5.</strong> Your First Move</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="your-first-move/hello-world.html"><strong aria-hidden="true">5.1.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="your-first-move/adding-tests.html"><strong aria-hidden="true">5.2.</strong> Adding Tests</a></li><li class="chapter-item expanded "><a href="your-first-move/debugging.html"><strong aria-hidden="true">5.3.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="your-first-move/generating-docs.html"><strong aria-hidden="true">5.4.</strong> Generating Docs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Publishing</div></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">6.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/packages.html"><strong aria-hidden="true">6.1.</strong> What is a Package</a></li><li class="chapter-item expanded "><a href="concepts/manifest.html"><strong aria-hidden="true">6.2.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="concepts/address.html"><strong aria-hidden="true">6.3.</strong> Addresses</a></li><li class="chapter-item expanded "><a href="concepts/modules.html"><strong aria-hidden="true">6.4.</strong> Module</a></li><li class="chapter-item expanded "><a href="concepts/user-interaction.html"><strong aria-hidden="true">6.5.</strong> Interacting with a Package</a></li><li class="chapter-item expanded "><a href="concepts/what-is-an-account.html"><strong aria-hidden="true">6.6.</strong> Account</a></li><li class="chapter-item expanded "><a href="concepts/what-is-a-transaction.html"><strong aria-hidden="true">6.7.</strong> Transaction</a></li><li class="chapter-item expanded "><a href="concepts/object-storage.html"><strong aria-hidden="true">6.8.</strong> Object Storage</a></li></ol></li><li class="chapter-item expanded "><a href="hello-sui/index.html"><strong aria-hidden="true">7.</strong> Your First Sui App</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-sui/hello-world.html"><strong aria-hidden="true">7.1.</strong> Hello Sui!</a></li><li class="chapter-item expanded "><a href="hello-sui/build-and-publish.html"><strong aria-hidden="true">7.2.</strong> Build and Publish</a></li><li class="chapter-item expanded "><a href="hello-sui/testing.html"><strong aria-hidden="true">7.3.</strong> Testing</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Ideas</div></li></ol></li><li class="chapter-item expanded "><a href="basic-syntax/index.html"><strong aria-hidden="true">8.</strong> Syntax Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic-syntax/module.html"><strong aria-hidden="true">8.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="basic-syntax/comments.html"><strong aria-hidden="true">8.2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="basic-syntax/primitive-types.html"><strong aria-hidden="true">8.3.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="basic-syntax/address.html"><strong aria-hidden="true">8.4.</strong> Address</a></li><li class="chapter-item expanded "><a href="basic-syntax/struct.html"><strong aria-hidden="true">8.5.</strong> Struct</a></li><li class="chapter-item expanded "><a href="basic-syntax/copy-and-drop.html"><strong aria-hidden="true">8.6.</strong> Copy and Drop</a></li><li class="chapter-item expanded "><a href="basic-syntax/standard-library.html"><strong aria-hidden="true">8.7.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="basic-syntax/string.html"><strong aria-hidden="true">8.8.</strong> String</a></li><li class="chapter-item expanded "><a href="basic-syntax/vector.html"><strong aria-hidden="true">8.9.</strong> Vector</a></li><li class="chapter-item expanded "><a href="basic-syntax/option.html"><strong aria-hidden="true">8.10.</strong> Option</a></li><li class="chapter-item expanded "><a href="basic-syntax/control-flow.html"><strong aria-hidden="true">8.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="basic-syntax/constants.html"><strong aria-hidden="true">8.12.</strong> Constants</a></li><li class="chapter-item expanded "><a href="basic-syntax/assert-and-abort.html"><strong aria-hidden="true">8.13.</strong> Assert and Abort</a></li><li class="chapter-item expanded "><a href="basic-syntax/function.html"><strong aria-hidden="true">8.14.</strong> Function</a></li><li class="chapter-item expanded "><a href="basic-syntax/struct-methods.html"><strong aria-hidden="true">8.15.</strong> Struct Methods</a></li><li class="chapter-item expanded "><a href="basic-syntax/visibility.html"><strong aria-hidden="true">8.16.</strong> Visibility Modifiers</a></li><li class="chapter-item expanded "><a href="basic-syntax/borrow-checker.html"><strong aria-hidden="true">8.17.</strong> References</a></li><li class="chapter-item expanded "><a href="basic-syntax/generics.html"><strong aria-hidden="true">8.18.</strong> Generics</a></li></ol></li><li class="chapter-item expanded "><a href="object/index.html"><strong aria-hidden="true">9.</strong> It starts with an Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="object/key-ability.html"><strong aria-hidden="true">9.1.</strong> The Key Ability</a></li><li class="chapter-item expanded "><a href="object/what-is-an-object.html"><strong aria-hidden="true">9.2.</strong> What is an Object</a></li><li class="chapter-item expanded "><a href="object/true-ownership.html"><strong aria-hidden="true">9.3.</strong> True Ownership</a></li><li class="chapter-item expanded "><a href="object/transfer-restrictions.html"><strong aria-hidden="true">9.4.</strong> Transfer Restrictions</a></li><li class="chapter-item expanded "><a href="object/shared-state.html"><strong aria-hidden="true">9.5.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="object/transfer-to-object.html"><strong aria-hidden="true">9.6.</strong> Transfer to Object?</a></li></ol></li><li class="chapter-item expanded "><a href="programmability/index.html"><strong aria-hidden="true">10.</strong> Advanced Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programmability/fast-path.html"><strong aria-hidden="true">10.1.</strong> Fast Path</a></li><li class="chapter-item expanded "><a href="programmability/transaction-context.html"><strong aria-hidden="true">10.2.</strong> Transaction Context</a></li><li class="chapter-item expanded "><a href="programmability/dynamic-fields.html"><strong aria-hidden="true">10.3.</strong> Dynamic Fields</a></li><li class="chapter-item expanded "><a href="programmability/collections.html"><strong aria-hidden="true">10.4.</strong> Collections</a></li><li class="chapter-item expanded "><a href="programmability/abstract-classes.html"><strong aria-hidden="true">10.5.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="programmability/testing.html"><strong aria-hidden="true">10.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="programmability/epochs.html"><strong aria-hidden="true">10.7.</strong> Epoch and Time</a></li><li class="chapter-item expanded "><a href="programmability/package-upgrades.html"><strong aria-hidden="true">10.8.</strong> Package Upgrades</a></li><li class="chapter-item expanded "><a href="programmability/transaction-blocks.html"><strong aria-hidden="true">10.9.</strong> Transaction Blocks</a></li><li class="chapter-item expanded "><a href="programmability/authorization-patterns.html"><strong aria-hidden="true">10.10.</strong> Authorization Patterns</a></li><li class="chapter-item expanded "><a href="programmability/cryptography-and-hashing.html"><strong aria-hidden="true">10.11.</strong> Cryptography and Hashing</a></li><li class="chapter-item expanded "><a href="programmability/randomness.html"><strong aria-hidden="true">10.12.</strong> Randomness</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Standards</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> Coin</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Transfer Policy</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Kiosk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> Closed Loop Token</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Special Topics</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> BCS</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Coding Conventions</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Guides</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/upgradeability-practices.html"><strong aria-hidden="true">13.1.</strong> Upgradability Practices</a></li><li class="chapter-item expanded "><a href="guides/building-against-limits.html"><strong aria-hidden="true">13.2.</strong> Building against Limits</a></li><li class="chapter-item expanded "><a href="guides/testing.html"><strong aria-hidden="true">13.3.</strong> Testing</a></li><li class="chapter-item expanded "><a href="guides/debugging.html"><strong aria-hidden="true">13.4.</strong> Debugging</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sui-notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!--

What is this book about?

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<!--

Why this book, why we wrote it, what we hope to achieve with it.

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="history"><a class="header" href="#history">History</a></h1>
<!--

Chapter: History
Goal: explain the history of Move as a language
Notes:

 -->
<ul>
<li>2019 - Libra is announced</li>
<li>2019 - Move a Language with Programmable Resources</li>
<li>2022 - The Diem Association is closed, Move is open sourced</li>
<li>2023 - ...</li>
<li>2024 - Move 2024 is released</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-we-begin"><a class="header" href="#before-we-begin">Before we begin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-sui"><a class="header" href="#install-sui">Install Sui</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-your-ide"><a class="header" href="#set-up-your-ide">Set up your IDE</a></h1>
<p>There are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide basic features like syntax highlighting and error messages, though they differ in their additional features. Whatever IDE you choose, you'll need to use the terminal to run the Move CLI.</p>
<blockquote>
<p><strong>IntelliJ Plugin does not support Move 2024 edition fully, some syntax won't get highlighted and not supported.</strong></p>
</blockquote>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a> is a free and open source IDE from Microsoft.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=move.move-analyzer">Move Analyzer</a> is a language server extension for Move maintained by <a href="https://mystenlabs.com">MystenLabs</a>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> a simple syntax highlighting extension for Move by <a href="https://github.com/damirka/">Damir Shamanaev</a>.</li>
</ul>
<h2 id="intellij-idea"><a class="header" href="#intellij-idea">IntelliJ IDEA</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is a commercial IDE from JetBrains.</li>
<li><a href="https://plugins.jetbrains.com/plugin/14721-move-language">Move Language Plugin</a> provides a Move language extension for IntelliJ IDEA by <a href="https://pontem.network/">Pontem Network</a>.</li>
</ul>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<ul>
<li><a href="https://www.gnu.org/software/emacs/">Emacs</a> is a free and open source text editor.</li>
<li><a href="https://github.com/amnn/move-mode">move-mode</a> is a Move mode for Emacs by <a href="https://github.com/amnn">Ashok Menon</a>.</li>
</ul>
<h2 id="github-codespaces"><a class="header" href="#github-codespaces">Github Codespaces</a></h2>
<p>Web based IDE from Github, can be run right in the browser and provides almost a full-featured VSCode experience.</p>
<ul>
<li><a href="https://github.com/features/codespaces">Github Codespaces</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> is also available in the extensions marketplace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-2024"><a class="header" href="#move-2024">Move 2024</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-move"><a class="header" href="#your-first-move">Your first Move</a></h1>
<p>In this section you'll get to experience the Move language first-hand. You'll learn how to create a package, write a simple module, test it, generate documentation and publish it on-chain. While the guide is not complete on the last part (as every network has specifics on how to publish a package), it will give you a good idea of how to work with Move.</p>
<p>This guide will reference topics which you will learn later in this book. If you are not familiar with some of the concepts, don't worry, you'll learn them later. Try to focus on the task at hand and don't get distracted by the details.</p>
<blockquote>
<p>It is important that you have a working Move environment. If you haven't set it up yet, please refer to the <a href="your-first-move/../install-sui.html">Install Sui</a> section. </p>
</blockquote>
<p>This section is divided into the following parts (in order):</p>
<ul>
<li><a href="your-first-move/hello-world.html">Hello World</a></li>
<li><a href="your-first-move/adding-tests.html">Adding Tests</a></li>
<li><a href="your-first-move/debugging.html">Debugging</a></li>
<li><a href="your-first-move/generating-docs.html">Generating Docs</a></li>
<li><a href="your-first-move/./publish-a-package.html">Publish a package</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>It's time to write your first Move program. We'll start with the classic &quot;Hello World&quot; program which returns a String. First, you need to initialize a new project, the process was previously described on the <a href="your-first-move/../getting-started/project-setup.html">Project Setup</a> page.</p>
<p>By running a Move CLI <code>new</code> function, you get this folder structure:</p>
<pre><code class="language-bash">sources/
Move.toml
</code></pre>
<p>The address I'm using in this book is always <code>0x0</code> and the name for it is &quot;book&quot;. You can use any address you want, but make sure to change it in the examples. To make the examples work as is, please, add the following address to the <code>[addresses]</code> section in the <code>Move.toml</code>:</p>
<pre><code class="language-toml"># Move.toml
[addresses]
std = &quot;0x1&quot;
book = &quot;0x0&quot;
</code></pre>
<h2 id="create-a-module"><a class="header" href="#create-a-module">Create a module</a></h2>
<p>Let's create a new module called <code>hello_world</code>. To do so, create a new file in the <code>sources</code> folder called <code>hello_world.move</code>. So that the structure looks like this:</p>
<pre><code class="language-bash">sources/
    hello_world.move
Move.toml
</code></pre>
<p>And then add the following code to the <code>hello_world.move</code> file:</p>
<pre><code class="language-Move">// sources/hello_world.move
module book::hello_world {
    use std::string::{Self, String};

    public fun hello_world(): String {
        string::utf8(b&quot;Hello, World!&quot;)
    }
}
</code></pre>
<p>While it's not a hard restriction, it's is considered a good practice to name the module the same as the file. So, in our case, the module name is <code>hello_world</code> and the file name is <code>hello_world.move</code>.</p>
<p>The module name and function names should be in <code>snake_case</code> - all lowercase letters with underscores between words. You can read more about coding conventions in the <a href="your-first-move/../special-topics/coding-conventions.html">Coding Conventions</a> section.</p>
<h2 id="dive-into-the-code"><a class="header" href="#dive-into-the-code">Dive into the code</a></h2>
<p>Let's take a closer look at the code we just wrote:</p>
<pre><code class="language-Move">module book::hello_world {
}
</code></pre>
<p>The first line of code declares a module called <code>hello_world</code> stored at the address <code>book</code>. The contents of the module go inside the curly braces <code>{}</code>. The last line closes the module declaration with a closing curly brace <code>}</code>. We will go through the module declaration in more detail in the <a href="your-first-move/../syntax-basics/modules.html">Modules</a> section.</p>
<p>Then we import two members of the <code>std::string</code> module (which is part of the <code>std</code> package). The <code>string</code> module contains the <code>String</code> type, and the <code>Self</code> keyword imports the module itself, so we can use its functions.</p>
<pre><code class="language-Move">    use std::string::{Self, String};
</code></pre>
<p>Then we define a <code>hello_world</code> function using the keyword <code>fun</code> which takes no arguments and returns a <code>String</code> type. The <code>public</code> keyword marks the visibility of the function - &quot;public&quot; functions can be accessed by other modules. The function body is inside the curly braces <code>{}</code>.</p>
<blockquote>
<p>In the <a href="your-first-move/../syntax-basics/function.html">Function</a> section we will learn more about functions.</p>
</blockquote>
<pre><code class="language-Move">    public fun hello_world(): String {
        string::utf8(b&quot;Hello, World!&quot;)
    }
</code></pre>
<p>The function body consists of a single function call to the <code>string::utf8</code> function and returns a <code>String</code> type. The expression is a bytestring literal <code>b&quot;Hello World!&quot;</code>.</p>
<h2 id="compile-the-package"><a class="header" href="#compile-the-package">Compile the package</a></h2>
<p>To compile the package, run the following command:</p>
<pre><code class="language-bash">$ sui move build
</code></pre>
<p>If you see this (or - for other binaries - similar) output, then everything is fine, and the code compiled successfully:</p>
<pre><code class="language-bash">&gt; UPDATING GIT DEPENDENCY https://github.com/move-language/move.git
&gt; INCLUDING DEPENDENCY MoveStdlib
&gt; BUILDING Book
</code></pre>
<p>Congratulations! You've just compiled your first Move program. Now, let's add a test and some logging so we see that it works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-tests"><a class="header" href="#adding-tests">Adding Tests</a></h1>
<p>To run a Move program there needs to be an environment which stores packages and executes transactions. The best way to test a Move program is to write some tests and run them locally. Move has built-in testing functionality, and the tests are written in Move as well. In this section, we will learn how to write tests for our <code>hello_world</code> module.</p>
<p>First, let's try to run tests. All of the Move binaries support the <code>test</code> command, and this is the command we will use to run tests:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>If you see similar output, then everything is fine, and the test command has run successfully:</p>
<pre><code class="language-bash">INCLUDING DEPENDENCY MoveStdlib
BUILDING Book Samples
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
</code></pre>
<p>As you can see, the test command has run successfully, but it didn't find any tests. Let's add some tests to our module.</p>
<h2 id="your-first-test"><a class="header" href="#your-first-test">Your first test</a></h2>
<p>When the test command runs, it looks for all tests in all files in the directory. Tests can be either placed separate modules or in the same module as the code they test. First, let's add a test function to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">module book::hello_world {
    use std::string::{Self, String};

    public fun hello_world(): String {
        string::utf8(b&quot;Hello, World!&quot;)
    }

    #[test]
    fun test_is_hello_world() {
        let expected = string::utf8(b&quot;Hello, World!&quot;);
        assert!(hello_world() == expected, 0)
    }
}
</code></pre>
<p>The test function is a function with a <code>#[test]</code> attribute. Normally it takes no arguments (but it can take arguments in some cases - you'll learn more about it closer to the end of this book) and returns nothing. Tests placed in the same module as the code they test are called &quot;unit tests&quot;. They can access all functions and types in the module. We'll go through them in more detail in the <a href="your-first-move/../syntax-basics/test.html">Test</a> section.</p>
<pre><code class="language-Move">    #[test]
    fun test_is_hello_world() {
        let expected = string::utf8(b&quot;Hello, World!&quot;);
        assert!(hello_world() == expected, 0)
    }
</code></pre>
<p>Inside the test function, we define the expected outcome by creating a String with the expected value and assign it to the <code>expected</code> variable. Then we use the special built-in <code>assert!()</code> which takes two arguments: a conditional expression and an error code. If the expression evaluates to <code>false</code>, then the test fails with the given error code. The equality operator <code>==</code> compares the <code>actual</code> and <code>expected</code> values and returns <code>true</code> if they are equal. We'll learn more about expressions in the <a href="your-first-move/../syntax-basics/expression-and-scope.html">Expression and Scope</a> section.</p>
<p>Now let's run the test command again:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>You should see this output, which means that the test has run successfully:</p>
<pre><code class="language-bash">...
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<h2 id="failed-experiment"><a class="header" href="#failed-experiment">Failed experiment</a></h2>
<p>Try replacing the equality operator  <code>==</code> inside the <code>assert!</code> with the inequality operator <code>!=</code> and run the test command again.</p>
<pre><code class="language-Move">    assert!(hello_world() != expected, 0)
</code></pre>
<p>You should see this output, which means that the test has failed:</p>
<pre><code class="language-bash">Running Move unit tests
[ FAIL    ] 0x0::hello_world::test_is_hello_world

Test failures:

Failures in 0x0::hello_world:

┌── test_is_hello_world ──────
│ error[E11001]: test failure
│    ┌─ ./sources/your-first-move/hello_world.move:14:9
│    │
│ 12 │     fun test_is_hello_world() {
│    │         ------------------- In this function in 0x0::hello_world
│ 13 │         let expected = string::utf8(b&quot;Hello, World!&quot;);
│ 14 │         assert!(hello_world() != expected, 0)
│    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to error, but it aborted with code 0 originating in the module 00000000000000000000000000000000::hello_world rooted here
│
│
└──────────────────

Test result: FAILED. Total tests: 1; passed: 0; failed: 1
</code></pre>
<p>Tests are used to verify the execution of the code. If the code is correct, the test should pass, otherwise it should fail. In this case, the test failed because we intentionally made a mistake in the test code. However, normally you should write tests that check the correctness of the code, not the other way around!</p>
<p>In the next section, we will learn how to debug Move programs and print intermediate values to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Now that we have a package with a module and a test, let's take a slight detour and learn how to debug Move programs. Move Compiler has a built-in debugging tool that allows you to print intermediate values to the console. This is especially useful when you are writing tests and want to see what's going on inside the program.</p>
<h2 id="new-import"><a class="header" href="#new-import">New import</a></h2>
<p>To use the <code>debug</code> module, we need to import it in our module. Imports are usually grouped together for readability and they are placed at the top of the module. Let's add the import statement to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">module book::hello_world {
    use std::string::{Self, String};
    use std::debug; // the added import!
</code></pre>
<p>Having imported the <code>std::debug</code> module, we can now use its functions. Let's add a <code>debug::print</code> function call to the <code>hello_world</code> function. To achieve that we need to change the function body. Instead of returning the value right away we will assign it to a variable, print it to the console and then return it:</p>
<pre><code class="language-Move">    public fun hello_world(): String {
        let result = string::utf8(b&quot;Hello, World!&quot;);
        debug::print(&amp;result);
        result
    }
</code></pre>
<p>First, run the build command:</p>
<pre><code class="language-bash">$ sui move build
</code></pre>
<p>The output does not contain anything unusual, because our code was never executed. But running <code>build</code> is an important part of the routine - this way we make sure that the changes we added can compile. Let's run the test command now:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>The output of the test command now contains the &quot;Hello, World!&quot; string:</p>
<pre><code class="language-bash">INCLUDING DEPENDENCY MoveNursery
INCLUDING DEPENDENCY MoveStdlib
BUILDING Book Samples
Running Move unit tests
[debug] &quot;Hello, World!&quot;
[ PASS    ] 0x0::hello_world::test_is_hello_world
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<p>Now every time the <code>hello_world</code> function is run in tests, you'll see the &quot;Hello, World!&quot; string in the output.</p>
<h2 id="correct-usage"><a class="header" href="#correct-usage">Correct usage</a></h2>
<p>Debug should only be used in local environment and never published on-chain. Usually, during the publish, the <code>debug</code> module is either removed from the package or the publishing fails with an error. There's no way to use this functionality on-chain.</p>
<h2 id="hint"><a class="header" href="#hint">Hint</a></h2>
<p>There's one trick that allows you to save some time while debugging. Instead of adding a module-level import, use a fully qualified function name. This way you don't need to add an import statement to the module, but you can still use the <code>debug::print</code> function:</p>
<pre><code class="language-Move">    std::debug::print(&amp;my_variable);
</code></pre>
<p>Be mindful that the value passed into debug should be a reference (the <code>&amp;</code> symbol in front of the variable name). If you pass a value, the compiler will emit an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-documentation"><a class="header" href="#generating-documentation">Generating Documentation</a></h1>
<p>Move CLI has a built-in tool for generating documentation for Move modules. The tool is included into the binary and available out of the box. In this section we will learn how to generate documentation for our <code>hello_world</code> module.</p>
<h2 id="adding-documentation-comments"><a class="header" href="#adding-documentation-comments">Adding documentation comments</a></h2>
<p>To generate documentation for a module, we need to add documentation comments to the module and its functions. Documentation comments are written in Markdown and start with <code>///</code> (three slashes). For example, let's add a documentation comment to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">/// This module contains a function that returns a string &quot;Hello, World!&quot;.
module book::hello_world {
</code></pre>
<p>Doc comments placed above the module are linked to the module itself, while doc comments placed above the function are linked to the function.</p>
<pre><code class="language-Move">    /// As the name says: returns a string &quot;Hello, World!&quot;.
    public fun hello_world(): String {
        string::utf8(b&quot;Hello, World!&quot;)
    }
</code></pre>
<p>If a documented member has an attribute, such as <code>#[test]</code> in the example below, the doc comment must be placed <em>after</em> the attribute:</p>
<blockquote>
<p>While it is possible to document <code>#[test]</code> functions, doc comments for tests will not be included in the generated documentation.</p>
</blockquote>
<pre><code class="language-Move">    #[test]
    /// This is a test for the `hello_world` function.
    fun test_is_hello_world() {
        let expected = string::utf8(b&quot;Hello, World!&quot;);
        let actual = hello_world();

        assert!(actual == expected, 0)
    }
</code></pre>
<h2 id="generating-documentation-1"><a class="header" href="#generating-documentation-1">Generating documentation</a></h2>
<p>To generate documentation for a module, we need to run the <code>sui move build</code> command with a <code>--doc</code> flag. Let's run the command:</p>
<pre><code class="language-bash">$ sui move build --doc
...
...
BUILDING Book Samples
</code></pre>
<blockquote>
<p>Alternatively, you can use <code>move test --doc</code> - this can be useful if you want to test and generate documentation at the same time. For example, as a part of your CI/CD pipeline.</p>
</blockquote>
<p>Once the build is complete, the documentation will be available in the <code>build/docs</code> directory. Each modile will have its own <code>.md</code> file. The documentation for the <code>hello_world</code> module will be available in the <code>build/docs/hello_world.md</code> file.</p>
<details>
<summary><a style="cursor: pointer">Click to see an example of the `hello_world.md` contents</a></summary>
<pre><code class="language-move">&lt;a name=&quot;0x0_hello_world&quot;&gt;&lt;/a&gt;

# Module `0x0::hello_world`
This module contains a function that returns a string &quot;Hello, World!&quot;.
-  [Function `hello_world`](#0x0_hello_world_hello_world)
&lt;pre&gt;&lt;code&gt;&lt;b&gt;use&lt;/b&gt; &lt;a href=&quot;&quot;&gt;0x1::debug&lt;/a&gt;;
&lt;b&gt;use&lt;/b&gt; &lt;a href=&quot;&quot;&gt;0x1::string&lt;/a&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;a name=&quot;0x0_hello_world_hello_world&quot;&gt;&lt;/a&gt;

## Function `hello_world`
As the name says: returns a string &quot;Hello, World!&quot;.
&lt;pre&gt;&lt;code&gt;&lt;b&gt;fun&lt;/b&gt; &lt;a href=&quot;hello_world.md#0x0_hello_world&quot;&gt;hello_world&lt;/a&gt;(): &lt;a href=&quot;_String&quot;&gt;string::String&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt;Implementation&lt;/summary&gt;
&lt;pre&gt;&lt;code&gt;&lt;b&gt;fun&lt;/b&gt; &lt;a href=&quot;hello_world.md#0x0_hello_world&quot;&gt;hello_world&lt;/a&gt;(): String {
    &lt;b&gt;let&lt;/b&gt; result = &lt;a href=&quot;_utf8&quot;&gt;string::utf8&lt;/a&gt;(b&quot;Hello, World!&quot;);
    &lt;a href=&quot;_print&quot;&gt;debug::print&lt;/a&gt;(&amp;result);
    result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-manifest"><a class="header" href="#package-manifest">Package Manifest</a></h1>
<p>The <code>Move.toml</code> file is a manifest file that describes the project and its dependencies. It has the following structure (varies depending on the network):</p>
<pre><code class="language-toml">[package]
name = &quot;my_project&quot;
version = &quot;0.0.0&quot;

[dependencies]
MoveStdlib = { git = &quot;https://github.com/move-language/move.git&quot;, subdir = &quot;language/move-stdlib&quot;, rev = &quot;main&quot; }

[addresses]
std =  &quot;0x1&quot;
</code></pre>
<p>Each section can have multiple fields, and some of them are optional.</p>
<ul>
<li>
<p><code>[package]</code> section describes the project metadata. It supports the following fields:</p>
<ul>
<li><code>name</code> - the name of the project. It should be unique within the network.</li>
<li><code>description</code> - the description of the project.</li>
<li><code>version</code> - the version of the project. It should be unique within the network.</li>
<li><code>authors</code> - the list of authors of the project.</li>
</ul>
</li>
<li>
<p><code>[dependencies]</code> section describes the project dependencies. Each dependency should have a name and a git repository URL (or a path to the local directory). Each</p>
</li>
<li>
<p><code>[addresses]</code> section adds aliases for the addresses. Any address can be specified in this section, and then used in the code as an alias. For example, if you add <code>std = &quot;0x1&quot;</code> to this section, you can use <code>0x1</code> as <code>std</code> in the code.</p>
</li>
<li>
<p><code>[dev-addresses]</code> - the same as <code>[addresses]</code>, but only works for the test and dev modes.</p>
</li>
<li>
<p><code>[dev-dependencies]</code> - the same as <code>[dependencies]</code>, but only works for the test and dev modes.</p>
</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="https://move-language.github.io/move/packages.html">Packages in the Move Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addresses"><a class="header" href="#addresses">Addresses</a></h1>
<!--

Chapter: Concepts
Goal: explain locations and addresses
Notes:
    - don't talk about the type
    - packages, accounts and objects are identified by addresses
    - addresses are 32 bytes long
    - addresses are unique
    - represented as hex strings (64 characters) prefixed with 0x
    - addresses are case insensitive

Links:
    - address type

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-a-package"><a class="header" href="#interacting-with-a-package">Interacting with a Package</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">Account</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-storage"><a class="header" href="#object-storage">Object Storage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-sui-app"><a class="header" href="#your-first-sui-app">Your First Sui App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-sui"><a class="header" href="#hello-sui">Hello Sui!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-publish"><a class="header" href="#build-and-publish">Build and Publish</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--

    Thoughts:
        someone will jump, some sections will be skipped, some will be read in a different order;

    Audiences:
        - people who don't know anything about Move
        - people who know Move but don't know Sui
        - people who know Sui but don't know Move
        - people who tried Move and Sui and need more

    This is an attempt to structure the narrative in a way that makes sense, and so that it builds
    up to the next section.

    Then why would we give "The first Move section" ?
        - it's great to give a taste of Move overall, without linking it to storage / specific blockchain
        - maybe it can be confusing; though if we call the first section "Hello Move", and the second
          "Hello Sui", then the reader would differentiate between the two
        // marking the above as an open question for now



    Introduction

    Foreword
        - this book is a product of collaboration between people who love Move and
          education and people who are incredibly smart and build the language

    What is Sui

    Setting Up the Environment
        - Install Sui
        - Set up your IDE
        - Project Setup         ??? not sure about this one
        - Manifest              ??? this one is also not sure

    Your First Move
        // goal: showcase main features of the CLI / compiler
        // note: this section is not about Sui, but about Move; it is interactive and
                can be run by anyone to get a taste of Move as a language and Sui CLI
                as a tool; it's pretty neat that Move has tests, and that there's a
                documentation generator, and that there's a way to debug the code;

        - Hello World
            - copy-paste the example
            - explain the structure of the code
            - explain the module
            - explain the function
            - run sui move build
            - compare the output
            - leave a hint, show that there's more to it
        - Adding Tests
            - describe what a test is
            - copy-paste the example into the code
            - explain the test
            - run sui move test
            - compare the output
            - try to break the test
            - check the output
            - leave a hint
            - anticipation for the next section
        - Debugging
            - describe what Move Compiler can do for debugging
            - debug is only available in test mode
            - copy-paste the example
            - explain the imported `std::debug` module
            - give a hint on how to do an inline call
            - pretty-print for strings / vectors
            - other debug functions: print, print_stack_trace
        - Generating Docs
            - why docs are important
            - copy-paste the example
            - describe doc comments and what can be commented
            - show the output of the doc command
            - give a hint on how to set up the CIs
            - running --doc in `sui move test`
        - Publishing (devnet or testnet) ???
            - we need a quick account + network setup (work with Stefan)
            - describe the process of publishing
            ? should we publish the package in another section ?
            ? it goes beyond "get to know CLI" at the same time doesn't

    In order: how do we call this section? // think about it
        - packages and how they're stored
            - overview of packages and their contents (use a diagram)
            - how a package is created, and what it consists of
            - what is the package manifest
            - describe how "name" field is used
            - mention the "edition" field
            - what are the folders in a package and what are they for
            - how packages are imported (give Sui as an example)
            - what are addresses, and how they identify packages
            - how packages are published
            - leave a note that packages are also *upgradable*
        - mention what an address is, because it identifies a package
            - address is used for packages, objects, and accounts
            - address is a 32-byte value
            - address is written in hexadecimal notation
            - don't describe the type yet
            - focus on the concept of address on blockchain and on Sui in particular
        - then the modules, where they're stored and how they're published
            - package consists of modules
            - modules are stored in the sources directory
            - there can be any number of modules in a package
            - modules can be stored at any path under sources
            - there can be other folders storing tests and examples
            - compiler protects non-sources modules from being published
            - module definition and path
            - module members are accessed via a path
        - how user interacts with a program
            - mention public functions
            - give a concept of an entry / public function without getting into details
            - mention that functions are called in transactions
            - mention that transactions are sent by accounts
            - every transaction specifies object it operates on
        - user is an account
            - account is identified by an address
            - account is generated from a private key
            - account can own objects
            - account can send transactions
            - every transaction has a sender
            - sender is identified by an address
        - now objects?
            - Sui does not have global storage
            - storage is split into a pool of objects
            - objects are identified by a 32-byte value
            - objects are stored in the blockchain storage
            - focus on infrastructure properties of objects

        // note: it may be a good idea to build an e2e example, because:
        //     - the reader will have a working application which they can modify
        //     - it gives an overview of how things function, and shall they stop,
        //       this is a great place to leave with some complete knowledge
        //     - the example can contain

        Hello Sui
            - what is Sui

            - Publishing (devnet or testnet)
                - we need a quick account + network setup (work with Stefan)
                - describe the process of publishing
                ? should we publish the package in another section ?
                ? it goes beyond "get to know CLI" at the same time doesn't


 -->
<h1 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h1>
<p>Before we get to the part that is the most exciting about Sui, we need to learn some basics. In this section, we will learn about the basic syntax of the Move language, setting the foundation for the rest of the book.</p>
<h2 id="code-organization"><a class="header" href="#code-organization">Code Organization</a></h2>
<p>The base unit of code organization in Move is a package. A package is a collection of modules. A module is a collection of functions, types, and other items. A package is published on the blockchain as a single unit. A package can be imported by other packages.</p>
<pre><code>package 0x...
    module a
        struct A1
        struct A2
    module b
</code></pre>
<blockquote>
<h3 id="remember"><a class="header" href="#remember">Remember</a></h3>
<ul>
<li>Package is published and identified via an address, eg <code>0x0</code>.</li>
<li>Modules are accessed via a path, eg <code>0x0::module</code>.</li>
<li>Module members are accessed via a path, eg <code>0x0::module::member</code>.</li>
</ul>
</blockquote>
<p>Given that there can be only one module member with a given name, the path <code>0x0::module::member</code> is unique and can be used to access the member. The path <code>0x0::module</code> is also unique and can be used to access the module. The path <code>0x0</code> is also unique and can be used to access the package.</p>
<p>Package consists of modules - separate scopes that contain functions, types, and other items. Modules can import and use other modules, and modules placed in the same package may have special access to each other.</p>
<h2 id="address"><a class="header" href="#address">Address</a></h2>
<p>Addresses mark the location of objects in the blockchain. On Sui, an address is a 32-byte value. Addresses are used to identify packages and objects. Addresses are written in hexadecimal notation, eg <code>0x0</code>.</p>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<p>A package is a directory with a <code>Move.toml</code> file and a <code>sources</code> directory. The <code>Move.toml</code> file contains metadata about the package, and the <code>sources</code> directory contains the source code of the package. On Sui, the package manifest usually looks like this:</p>
<pre><code class="language-toml">[package]
name = &quot;book&quot;
edition = &quot;2024.alpha&quot;

[dependencies]
Sui = {
    git = &quot;https://github.com/MystenLabs/sui.git&quot;,
    subdir = &quot;crates/sui-framework/packages/sui-framework&quot;,
    rev = &quot;framework/testnet&quot;
}

[addresses]
book = &quot;0x0&quot;
</code></pre>
<p>The <code>name</code> field contains the name of the package. It is not a published name, but a name of the package when it is imported by other packages. The <code>edition</code> field contains the edition of the Move language, the &quot;2024&quot; edition is the most recent one. The <code>dependencies</code> section contains package dependencies. To run meaningful applications on Sui, you need to have the <code>Sui</code> package as a dependency.</p>
<p>The addresses section contains named aliases for addresses. Not yet published package always has the address <code>0x0</code>, but when it is published, the address should be changed to the actual address. Compiler will replace the aliases with the actual addresses when compiling the package.</p>
<!-- This is a good example for why the book format is great -->
<p>For convenience and readability, addresses section should contain at least one alias for the package address. It allows you to use the alias instead of the address when you need to access the package; it also splits the configuration and code, allowing you to change the value in one place. For example, instead of <code>0x0::module::member</code> you can use <code>book::module::member</code>.</p>
<p>Package is imported with its addresses - the <code>Sui</code> import will add <code>sui</code> and <code>std</code> aliases. They're standard aliases for Sui Framework - 0x2, and Standard Library - 0x1.</p>
<h2 id="module-1"><a class="header" href="#module-1">Module</a></h2>
<p>While package can be considered an organizational unit, module is where the code lives. Module is a collection of functions, types, constants and other items. Module is declared with the <code>module</code> keyword:</p>
<pre><code class="language-Move">module book::my_module {

}
</code></pre>
<p>The module declaration consists of the <code>module</code> keyword followed by the module path - a package address and a module name separated by <code>::</code>. The module path is followed by the module body - a collection of items inside curly braces <code>{}</code>. The module body is a scope, and all items inside it are inaccesible from outside the module by default.</p>
<p>Modules are stored in the <code>sources</code> directory (and its subdirectories). File system path doesn't affect the module path and will be omitted when publishing, so the module path is <code>book::my_module</code> regardless of the file system path. For example, if you have a directory structure like this:</p>
<pre><code>sources/
    basics/
        my/
            module.move
Move.toml
</code></pre>
<p>The module path will be <code>book::my_module</code>, and <strong>not</strong> <code>book::basics::my::module</code>.</p>
<p>Modules can import other modules and access public functions and types. The dependency needs to be declared in the package manifest, so that the compiler knows where to find it. We will learn more about imports in the <a href="basic-syntax/../syntax-basics/import.html">Import</a> section.</p>
<p>Directories other than <code>sources</code> will not be compiled by default and hence won't be published. You can use them to store tests, documentation, examples, and other files. Though all folders are scanned when compiling in &quot;test mode&quot;, so examples and tests can be checked for compilation errors.</p>
<p>Modules compiled in test mode won't be published, so there's no way to make a mistake publishing what wasn't meant to be published.</p>
<h2 id="interaction-with-the-blockchain"><a class="header" href="#interaction-with-the-blockchain">Interaction with the blockchain</a></h2>
<p>Function is a block of code that contains a sequence of statements and expressions. Function can take arguments and return a value. Function is declared with the <code>fun</code> keyword.</p>
<pre><code class="language-Move">module book::my_module {
    fun my_function() {}
}
</code></pre>
<p>Like any module member, functions are accessed via a path. The path consists of the module path and the function name separated by <code>::</code>. For example, if you have a function called <code>my_function</code> in the <code>my_module</code> module in the <code>book</code> package, the path to it will be <code>book::my_module::my_function</code>.</p>
<p>Functions can be called in a transaction. User can send a transaction containing a call to a function, and the function will be executed on the blockchain. We will learn more about transactions in the <a href="basic-syntax/../syntax-basics/transaction.html">Transaction</a> section. Any public function can be called in a transaction.</p>
<p>So, if we made the <code>my_function</code> public, we can call it in a transaction:</p>
<pre><code class="language-Move">module book::my_module {
    public fun my_function() {}
}
</code></pre>
<p>To call it, a user would need to send a transaction containing a &quot;move-call&quot;, which would roughly look like this:</p>
<pre><code class="language-bash">sui client call \
    --package 0x... \
    --module book::my_module \
    --function my_function \
    --gas-budget 10000000
</code></pre>
<p>Having said that, Move modules define the interface of the package. For example, if there's a need to implement a database-like system with addition, modification and deletion of records, the module would define a matching set of functions. And users would be able to call those functions in transactions.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>Move is an object-oriented language, and as such, it stores data in objects. Objects are instances of types with the <code>key</code> ability and are stored in the blockchain storage. Every Object has a <code>UID</code> - a unique identifier that is used to access the object. The <code>UID</code> is a 32-byte value, and it is generated when the object is created. The internal value of the UID also contains an address.</p>
<blockquote>
<p>Package is also an immutable (unchangeable) object stored in the blockchain storage. However, it is a special case, and can't be used to store data except for the package bytecode.</p>
</blockquote>
<h2 id="accounts"><a class="header" href="#accounts">Accounts</a></h2>
<p>Accounts are the main way to interact with the blockchain. Accounts are identified by addresses and can send transactions to the blockchain. An account is generated from a private key, and the private key is used to sign transactions. Every account has a standard 32-byte address.</p>
<p>Every transaction has a sender - an account that signed the transaction. The sender is identified by their address. Accounts can own objects</p>
<h2 id="end-to-end-example"><a class="header" href="#end-to-end-example">End to end example</a></h2>
<!--
    After we explained the basics of the code organization. I think it makes sense to give an example,
    Rust Book does it. It's a good way to show how the code is organized and how it works. And it will
    leave the reader with something to play with.

    So that when we get to the next section, they will be able to modify the code and see how it works.
    And it will be a good way to introduce the next section.

    The example should be simple and short. It should be something that can be explained in a few
    sentences. It should be something that can be modified and played with. It should be something
    that can be used as a base for the next section.

    Maybe that's the point where we introduce objects and storage? They won't appear any time soon, but
    some bits can be illustrated upfront to create this anticipation for what is possible.
-->
<h2 id="getting-ready"><a class="header" href="#getting-ready">Getting Ready</a></h2>
<p>Now that we know what a package, account and storage are, let's get to the basics and learn to write some code.</p>
<p>This section covers:</p>
<ul>
<li>types</li>
<li>functions</li>
<li>structs</li>
<li>constants</li>
<li>control flow</li>
<li>tests</li>
</ul>
<h2 id="primitive-types-and-variables"><a class="header" href="#primitive-types-and-variables">Primitive types and variables</a></h2>
<!--
    We know the basics of the package, module and function.
    Now we can introduce the function body and variables.

    How to make it interactive so that people can try it out? Not even run it per se but give them enough so they can get excited and play with it themselves. Maybe a playground?

    And which features of the language can make gears in their heads start turning? Maybe the ability to create a struct and store it in the storage? Or maybe the ability to create a function and call it in a transaction? Or maybe the ability to create a test and run it? All of these are legit.


-->
<p>Move has a set of primitive types that are built into the language. They are the building blocks of the language and are used to build more complex types. The primitive types are:</p>
<ul>
<li><code>bool</code> - boolean type, can be either <code>true</code> or <code>false</code>.</li>
<li>integers - unsigned integers of different sizes: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>u256</code></li>
<li><code>address</code> - address type, represents a location in the blockchain</li>
<li><code>vector</code> - vector type, represents a dynamic array of elements of the same type</li>
</ul>
<p>The first three types are primitive types, and the last one is a composite type. We will learn more about composite types in the <a href="basic-syntax/../syntax-basics/composite-types.html">Composite Types</a> section.</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>The <code>bool</code> type represents a boolean value. It can be either <code>true</code> or <code>false</code>. The <code>bool</code> type is used to represent a condition in control flow statements. For example, the <code>if</code> statement takes a <code>bool</code> value and executes the code inside the body if the value is <code>true</code>:</p>
<pre><code class="language-Move">module book::my_module {
    fun my_function() {
        if (true) {
            // this code will be executed
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-2"><a class="header" href="#module-2">Module</a></h1>
<!--

Chapter: Base Syntax
Goal: Introduce module keyword.
Notes:
    - modules are the base unit of code organization
    - module members are private by default
    - types internal to the module have special access rules
    - only module can pack and unpack its types

 -->
<p>Module is the base unit of code organization in Move. Modules are used to group and isolate code, and most of the members of the module are private to the module by default. In this section you will learn how to create a module.</p>
<h2 id="module-declaration"><a class="header" href="#module-declaration">Module declaration</a></h2>
<p>Modules are declared using the <code>module</code> keyword followed by the package address, module name and the module body inside the curly braces <code>{}</code>. The module name should be in <code>snake_case</code> - all lowercase letters with underscores between words. Modules names must be unique in the package.</p>
<p>Usually, a single file in the <code>sources/</code> folder contains a single module. The file name should match the module name - for example, a <code>donut_shop</code> module should be stored in the <code>donut_shop.move</code> file. You can read more about coding conventions in the <a href="basic-syntax/../special-topics/coding-conventions.html">Coding Conventions</a> section.</p>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/module.move:4:6}}
</code></pre>
<p>Structs, functions and constants, imports and friend declarations are all part of the module:</p>
<ul>
<li><a href="basic-syntax/../syntax-basics/struct.html">Structs</a></li>
<li><a href="basic-syntax/../syntax-basics/function.html">Functions</a></li>
<li><a href="basic-syntax/../syntax-basics/constant.html">Constants</a></li>
<li><a href="basic-syntax/../syntax-basics/import.html">Imports</a></li>
<li><a href="basic-syntax/../advanced-topics/a-friend-of-a-friend.html">Friend declarations</a></li>
</ul>
<h2 id="address--named-address"><a class="header" href="#address--named-address">Address / Named address</a></h2>
<p>Module address can be specified as both: an address &quot;literal&quot; (does not require <code>@</code> prefix) or a named address specified in the <a href="basic-syntax/../getting-started/package-manifest.html">Package Manifest</a>. In the example below, both are identical because there's a <code>book = &quot;0x0&quot;</code> record in the <code>[addresses]</code> section of the <code>Move.toml</code>.</p>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/module.move:4:10}}
</code></pre>
<h2 id="address-block"><a class="header" href="#address-block">Address block</a></h2>
<p>Before the introduction of the <code>address::module_name</code> syntax, modules were organized into <code>address {}</code> blocks. This way of code organization is still available today, but is not used widely. Modern practices imply having a single module per file, so the <code>address {}</code> block is rather a redundant construct.</p>
<blockquote>
<p>Module addresses can be omitted if modules are organized into <code>address {}</code> blocks.</p>
</blockquote>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/module.move:12:}}
</code></pre>
<p>The modules defined in this code sample will be accessible as:</p>
<ul>
<li><code>book::another_module</code></li>
<li><code>book::yet_another_module</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce comments.
Notes:
    - doc comments are used in docgen
    - only public members are documented
    - doc comments are placed in between attributes and the definition
    - doc comments are allowed for: modules, structs, functions, constants
    - give an example of how doc comments are translated
 -->
<p>Comments are a way to add notes or document your code. They are ignored by the compiler and don't result in the Move bytecode. You can use comments to explain what your code does, to add notes to yourself or other developers, to temporarily remove a part of your code, or to generate documentation. There are three types of comments in Move: line comment, block comment, and doc comment.</p>
<h2 id="line-comment"><a class="header" href="#line-comment">Line comment</a></h2>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/comments_line.move:4:}}
</code></pre>
<p>You can use double slash <code>//</code> to comment out the rest of the line. Everything after <code>//</code> will be ignored by the compiler.</p>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/comments_line_2.move:4:}}
</code></pre>
<h2 id="block-comment"><a class="header" href="#block-comment">Block comment</a></h2>
<p>Block comments are used to comment out a block of code. They start with <code>/*</code> and end with <code>*/</code>. Everything between <code>/*</code> and <code>*/</code> will be ignored by the compiler. You can use block comments to comment out a single line or multiple lines. You can even use them to comment out a part of a line.</p>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/comments_block.move:4:}}
</code></pre>
<p>This example is a bit extreme, but it shows how you can use block comments to comment out a part of a line.</p>
<h2 id="doc-comment"><a class="header" href="#doc-comment">Doc comment</a></h2>
<p>Documentation comments are special comments that are used to generate documentation for your code. They are similar to block comments, but they start with three slashes <code>///</code> and are placed before the definition of the item they document.</p>
<pre><code class="language-Move">{{#include ../../samples/sources/syntax-basics/comments_doc.move:4:}}
</code></pre>
<!-- Documentation comments are  -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-1"><a class="header" href="#address-1">Address</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce the address type
Notes:
    - a special type
    - named addresses via the Move.toml
    - address literals
    - 0x2 is 0x0000000...02

Links:
    - address concept
    - transaction context
    - Move.toml
    - your first move

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-drop"><a class="header" href="#copy-and-drop">Copy and Drop</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce Copy and Drop abilities of Move.
Notes:
    - compare them to primitive types introduces before;
    - what is an ability without drop
    - drop is not necessary for unpacking
    - make a joke about a bacteria pattern in the code
    - mention that a struct with only `drop` ability is called a Witness
    - mention that a struct without abilities is called a Hot Potato
    - mention that there are two more abilities which are covered in a later chapter

Links:
    - language reference (abilities)
    - authorization patterns (or witness)
    - hot potato pattern
    - key and store abilities (later chapter)

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce control flow statements.
Notes:
    - if/else is an expression
    - while () {} loop
    - continue and break
    - loop {}
    - infinite loop is possible but will lead to gas exhaustion
    - return keyword
    - if is an expression and as such requires a semicolon (!!!)

Links:
    - reference (control flow)
    - coding conventions (control flow)

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce constants.
Notes:
    - constants are immutable
    - constants are private
    - start with a capital letter always
    - stored in the bytecode (but w/o a name)
    - mention standard for naming constants

Links:
    - next section (abort and assert)
    - coding conventions (constants)
    - constants (language reference)
    
 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-and-abort"><a class="header" href="#assert-and-abort">Assert and Abort</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce abort keyword and `assert!` macro.
Notes:
    - previous chapter mentions constants
    - error constants standard ECamelCase
    - `assert!` macro
    - asserts should go before the main logic
    - Move has no catch mechanism
    - abort codes are local to the module
    - there are no error messages emitted
    - error codes should handle all possible scenarios in this module

Links:
    - constants (previous section)
 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="function"><a class="header" href="#function">Function</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-methods"><a class="header" href="#struct-methods">Struct Methods</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-modifiers"><a class="header" href="#visibility-modifiers">Visibility Modifiers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<!--

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)
    

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="it-starts-with-an-object"><a class="header" href="#it-starts-with-an-object">It starts with an Object</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-key-ability"><a class="header" href="#the-key-ability">The Key Ability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-an-object"><a class="header" href="#what-is-an-object">What is an Object</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="true-ownership"><a class="header" href="#true-ownership">True Ownership</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-restrictions"><a class="header" href="#transfer-restrictions">Transfer Restrictions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-to-object"><a class="header" href="#transfer-to-object">Transfer to Object?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-programmability"><a class="header" href="#advanced-programmability">Advanced Programmability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-path"><a class="header" href="#fast-path">Fast Path</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-context"><a class="header" href="#transaction-context">Transaction Context</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-fields"><a class="header" href="#dynamic-fields">Dynamic Fields</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoch-and-time"><a class="header" href="#epoch-and-time">Epoch and Time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-upgrades"><a class="header" href="#package-upgrades">Package Upgrades</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-blocks"><a class="header" href="#transaction-blocks">Transaction Blocks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-patterns"><a class="header" href="#authorization-patterns">Authorization Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptography-and-hashing"><a class="header" href="#cryptography-and-hashing">Cryptography and Hashing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="randomness"><a class="header" href="#randomness">Randomness</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgradability-practices"><a class="header" href="#upgradability-practices">Upgradability Practices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-against-limits"><a class="header" href="#building-against-limits">Building against Limits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-2"><a class="header" href="#testing-2">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
